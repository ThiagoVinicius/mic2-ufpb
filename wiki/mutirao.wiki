#summary Vamos ajustar as microinstruções
#labels problem,urgent,godhelpus

= Introduction =

Durante a leitura desta página, mantenha [http://en.wikipedia.org/wiki/File:Apollo13-wehaveaproblem_edit_1.ogg isto] e [http://en.wikipedia.org/wiki/Apollo_13#Explosion isso] sempre em mente.

*Preâmbulo:* Temos o microcódigo da MIC2, mas não temos a MIC2!!

*Detalhes do problema:*

  Copiamos o código das microinstruções para a MIC2, que possui 3 barramentos, e uma Unidade de Busca de Instruções (IFU).

  Temos implementada, a "MIC1.5", que possui 3 barramentos, e ~~uma Unidade de Busca de Instruções (IFU)~~

  Obviamente, não vai funcionar. Dúvidas?

*Mission statement:*

By any means necessary, criar código que funcione na MIC1.5. Para ontem!


*Informações adicionais:*
  As tarefas foram pré alocadas, por integrante. Cada um de vocês vai ficar responsável por uma ou mais instruções para adaptar para a MIC1.5, como pode ser visto abaixo.

  * *Uma dica:* O código de 'alto nível' da MIC1, quando montado para a MIC1.5 (automaticamente, pelo montador escrito em Java) funcionará perfeitamente. *However*, A MIC1.5 possui o barramento A, ausente na MIC1. Algumas linhas de código da MIC1 podem ser transformadas em uma só! (não é necessário armazenar um dos operandos, no registrador H, num ciclo, para somente no próximo utilizálo)

  Eu quero ver as instruções otimizadas ao máximo. Nada de sair copiando o código da MIC1, na cara de pau.

*Atenção:* Não alterem o código no montador java. Vocês podem usá-lo para testar se há erros de compilação ou não, mas por favor, sem bagunçar o código no SVN. _aliás, vou dar um lock nos arquivos code.txt e memory.mif_ Vou adotar este procedimento porque é provavel que algumas instruções cresçam, em número de linhas, mas não há endereços livres entre as instruções. Enquanto eu implemento a funcionalidade de mover instruções para cima e para baixo, todo mundo colando os seus códigos aqui mesmo.

*Prazo:* Para ontem _e não pensem que isso é brincadeira_
*Prazo:* Para ontem _e não pensem que isso é brincadeira_
*Prazo:* Para ontem _e não pensem que isso é brincadeira_
*Prazo:* Para ontem _e não pensem que isso é brincadeira_
*Prazo:* Para ontem _e não pensem que isso é brincadeira_
_e nem digam que eu não fui suficientemente claro_

*BOA SORTE!*


= Details =

Aqui está a escalação:

|| Instrução || Responsável || Comentários ||
||~~iADD~~   || Joedson     ||
||~~iSUB~~   || Jailton     ||
||  iAND     || Amanda      ||
||~~iOR~~    || Gabriela    ||
||~~iDUP~~   || Joedson     ||
||~~iPOP~~   || Jailton     ||
||  iSWAP    || Hugo        ||
||  iBIPUSH  || Amanda      ||
||~~iLOAD~~  || Gabriela    ||
|| ~~iSTORE~~|| Diénert     ||
|| ~~iWIDE~~ || nobody      ||   instrução abolida! ||
||  iINC     || Hugo        ||
|| ~~iGOTO~~ || Gutenberg   ||
||  iFLT     || Hugo        ||
|| ~~iIFEQ~~ || Gutenberg   ||
||~~iIF_CMP_EQ~~|| Diénert     || cuidado nessa linha envolve as microinstruções T e F!! ||
|| ~~iINVOKEVIRTUAL~~ || Gutenberg ||
|| ~~iRETURN~~ || Diénert     ||

Coloquem aqui abaixo, os códigos "alto nível", por favor, não quero ver zeros e uns. Não aqui.

{{{
iADD:
iadd1     MAR=SP=SP-1;rd
iadd2
iadd3     MDR = TOS = MDR + TOS; wr; goto Main1

iSUB:
isub1     MAR = SP = SP - 1; rd
isub2
isub3     MDR = TOS = MDR - TOS; wr; goto Main1

iDUP:
idup1     MAR =SP=SP+1
idup2     MDR = TOS; wr; goto Main1

iPOP:
ipop1     MAR = SP = SP - 1; rd
ipop2
ipop3     TOS = MDR; goto Main1

iGOTO:
igoto1    OPC = PC - 1
igoto2    PC = PC + 1; fetch
igoto3    H  = MBR << 8
igoto4    H  = MBRU or H
igoto5    PC = OPC + H; fetch
igoto6    goto Main1

iIFEQ:
iifeq1    MAR = SP = SP - 1; rd
iifeq2    OPC = TOS
iifeq3    TOS = MDR
iifeq4    Z = OPC; if (Z) goto T; else goto F

iINVOKEVIRTUAL:
iinvokevirtual1    PC = PC + 1; fetch
iinvokevirtual2    H  = MBRU << 8
iinvokevirtual3    H  = MBRU or H
iinvokevirtual4    MAR = CPP + H
iinvokevirtual5    OPC = PC + 1
iinvokevirtual6    PC = MDR; fetch
iinvokevirtual7    PC = PC + 1; fetch
iinvokevirtual8    H  = MBRU << 8
iinvokevirtual9    H  = MBRU or H
iinvokevirtual10   PC = PC + 1; fetch
iinvokevirtual11   TOS = SP - H
iinvokevirtual12   TOS = MAR = TOS + 1
iinvokevirtual13   PC = PC + 1; fetch
iinvokevirtual14   H  = MBRU << 8
iinvokevirtual15   H  = MBRU or H
iinvokevirtual16   MDR = SP + H + 1; wr
iinvokevirtual17   MAR = SP = MDR; 
iinvokevirtual18   MDR = OPC; wr 
iinvokevirtual19   MAR = SP = SP + 1 
iinvokevirtual20   MDR = LV; wr 
iinvokevirtual21   PC = PC + 1; fetch
iinvokevirtual22   LV = TOS; goto Main1 

iSTORE:
istore1:   MAR = MBRU + LV
istore2:   MDR = TOS; wr
istore3:   SP = MAR = SP - 1; rd
istore4:   PC = PC + 1; fetch
istore5:   TOS = MDR; goto Main1

iIF_CMP_EQ:
iif_cmp_eq1   MAR = SP = SP - 1; rd
iif_cmp_eq2   MAR = SP = SP - 1; rd
iif_cmp_eq3   OPC = TOS
iif_cmp_eq4   TOS = MDR
iif_cmp_eq5   Z = OPC - MDR; if (Z) goto T; else goto F

T:
t1    PC = PC + 1; fetch; goto goto2

F:
f1    PC = PC + 1
f2    PC = PC + 1; fetch
f3    goto Main1




iRETURN:
ireturn1:   MAR = SP = LV; rd
ireturn2:   
ireturn3:   LV = MAR = MDR;rd
ireturn4:   MAR = LV + 1
ireturn5:   PC = MDR; rd; fetch
ireturn6:   MAR = SP
ireturn7:   LV = MDR
ireturn8:   MDR = TOS; wr; goto Main1

iOR:
ior1   MAR = SP = SP-1;rd; goto ior2
ior2   goto ior3
ior3   MDR = TOS = MDR OR TOS; wr; goto Main1

iLOAD:
iload1   MAR = MBRU + LV; rd; goto iload2
iload2   MAR = SP = SP + 1; goto iload3
iload3   PC = PC + 1; fetch; wr; goto iload4
iload4   TOS = MDR; goto Main1

}}}